# LeetCode 75 Algorithms Practice

## Overview
This repository contains my practice solutions for the LeetCode 75 algorithms, a curated list designed to cover a range of essential algorithmic topics. It reflects my learning journey, and I will continue to update it as I progress. Feel free to explore the solutions â€” I welcome any feedback or suggestions!

## Topics Covered
Throughout this journey, I have worked through various topics including, but not limited to:

1. **Arrays & Hashing**  
   Fundamental problems involving arrays, hash maps, and sets that explore operations like searching, sorting, and frequency counting.

2. **Two Pointers**  
   Techniques to solve problems related to array partitioning, subarrays, and string manipulation using the two-pointer approach.

3. **Sliding Window**  
   Problems that focus on optimizing solutions with the sliding window technique, especially in scenarios involving subarrays or subsequences.

4. **Stack & Queues**  
   Implementations and applications of stacks and queues for managing sequences of operations in problems like evaluating expressions or processing data in a first-in, first-out manner.

5. **Binary Search**  
   Efficient searching techniques in sorted arrays, including classic problems like finding elements in log time, handling boundary cases, and solving optimization problems using binary search.

6. **Linked Lists**  
   Problems that require manipulation of singly and doubly linked lists, covering everything from basic operations to complex reordering.

7. **Trees**  
   Traversal methods (DFS, BFS) and recursion-based solutions for tree-based problems such as finding depths, validating tree structures, and building binary search trees (BST).

8. **Tries**  
   Working with prefix trees for problems that involve word searching, auto-completion, and efficient storage of large datasets of strings.

9. **Backtracking**  
   Recursive solutions for constraint-based problems, like solving puzzles or generating combinations, with an emphasis on exploring all possible configurations.

10. **Dynamic Programming**  
    Tackling problems with overlapping subproblems and optimal substructure using memoization and tabulation techniques.

11. **Graph Theory**  
    Depth-first search (DFS), breadth-first search (BFS), and shortest path algorithms for solving problems related to networks and connectivity.
